/*
 * Copyright (C) 2009 - 2022 Xilinx, Inc.
 * Copyright (C) 2022 - 2024 Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

#include <stdio.h>

#include "xparameters.h"
#include "xparameters_ps.h"
#include "xil_exception.h"
#include "xdebug.h"
#include "xscugic.h"
#include "lwip/err.h"
#include "xgpio.h"
#include "xaxidma.h"
#include "xscutimer.h"

#include "netif/xadapter.h"
#include "xil_util.h"

#include "platform.h"
#include "platform_config.h"
#if defined (__arm__) || defined(__aarch64__)
#include "xil_printf.h"
#endif

#include "lwip/tcp.h"
#include "xil_cache.h"

#if LWIP_IPV6==1
#include "lwip/ip.h"
#else
#if LWIP_DHCP==1
#include "lwip/dhcp.h"
#endif
#endif

#define MEM_BASE_ADDR (XPAR_PS7_DDR_0_S_AXI_BASEADDR + 0x01000000)
#define TX_BUFFER_BASE (MEM_BASE_ADDR + 0x00100000)
#define RX_BUFFER_BASE (MEM_BASE_ADDR + 0x00300000)

u8 *DmaTxBufferPtr;
u8 *DmaRxBufferPtr;
XScuGic Interrupt;
XAxiDma AxiDma;
XGpio Gpio;
volatile u32 DmaTxDone = 0;
volatile u32 DmaRxDone = 0;
volatile u32 DmaError = 1;
volatile u32 DmaWait = 0;
volatile u32 DmaRxFinal = 0;
static u16 GlobalIntrMask = 1;
static volatile u32 IntrFlag = 0;
u32_t tx_buf_i = 0;
u32_t tx_buffer[16];
u32_t init_buffer[8];
u32_t init_buf_i = 0;
u8_t rx_buffer[4];
u32_t a_rows;
u32_t a_cols;
u32_t b_cols;
u32_t fraction_bits;
u32_t rx_a_row = 0;
u32_t rx_b_col = 0;
volatile u32 DmaRepeat = 0;
extern XScuTimer TimerInstance;
extern int firstrxdone;
extern int firstrxinitiated;


/* defined by each RAW mode application */
void print_app_header();
int start_application();
int transfer_data();
void tcp_fasttmr(void);
void tcp_slowtmr(void);

/* missing declaration in lwIP */
void lwip_init();

#if LWIP_IPV6==0
#if LWIP_DHCP==1
extern volatile int dhcp_timoutcntr;
err_t dhcp_start(struct netif *netif);
#endif
#endif

extern volatile int TcpFastTmrFlag;
extern volatile int TcpSlowTmrFlag;
static struct netif server_netif;
struct netif *echo_netif;
struct tcp_pcb* pcb;

#if LWIP_IPV6==1
void print_ip6(char *msg, ip_addr_t *ip)
{
	print(msg);
	xil_printf(" %x:%x:%x:%x:%x:%x:%x:%x\n\r",
		   IP6_ADDR_BLOCK1(&ip->u_addr.ip6),
		   IP6_ADDR_BLOCK2(&ip->u_addr.ip6),
		   IP6_ADDR_BLOCK3(&ip->u_addr.ip6),
		   IP6_ADDR_BLOCK4(&ip->u_addr.ip6),
		   IP6_ADDR_BLOCK5(&ip->u_addr.ip6),
		   IP6_ADDR_BLOCK6(&ip->u_addr.ip6),
		   IP6_ADDR_BLOCK7(&ip->u_addr.ip6),
		   IP6_ADDR_BLOCK8(&ip->u_addr.ip6));

}
#else
void print_ip(char *msg, ip_addr_t *ip)
{
	print(msg);
	xil_printf("%d.%d.%d.%d\n\r", ip4_addr1(ip), ip4_addr2(ip),
		   ip4_addr3(ip), ip4_addr4(ip));
}

void print_ip_settings(ip_addr_t *ip, ip_addr_t *mask, ip_addr_t *gw)
{

	print_ip("Board IP: ", ip);
	print_ip("Netmask : ", mask);
	print_ip("Gateway : ", gw);
}
#endif

#if defined (__arm__) && !defined (ARMR5)
#if XPAR_GIGE_PCS_PMA_SGMII_CORE_PRESENT == 1 || XPAR_GIGE_PCS_PMA_1000BASEX_CORE_PRESENT == 1
int ProgramSi5324(void);
int ProgramSfpPhy(void);
#endif
#endif

#ifdef XPS_BOARD_ZCU102
#if defined (XPAR_XIICPS_0_DEVICE_ID) || defined (XPAR_XIICPS_0_BASEADDR)
int IicPhyReset(void);
#endif
#endif

static void DmaRxIntrHandler(void *Callback)
{
	xil_printf("Got to here 0");
	u32 IrqStatus;
    int TimeOut;
    err_t err;
    XAxiDma *AxiDmaInst = (XAxiDma *)Callback;

    IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DEVICE_TO_DMA);

    if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK)) {
        return;
    }

    xil_printf("Got to here 1\r\n");

    if ((IrqStatus & XAXIDMA_IRQ_ERROR_MASK)) {
        xil_printf("DMA RX Error occurred\r\n");

        XAxiDma_Reset(AxiDmaInst);
        TimeOut = 10000;
        while (TimeOut) {
            if (XAxiDma_ResetIsDone(AxiDmaInst)) {
                break;
            }
            TimeOut -= 1;
        }
		xil_printf("RX SimpleTransfer initiated\r\n");
		DmaError = 0;
		int Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaRxBufferPtr,
		4, XAXIDMA_DEVICE_TO_DMA);
		if (Status != XST_SUCCESS) {
			xil_printf("Failed to receive data from AXI DMA %d\r\n", Status);
			tcp_abort(pcb);
	    	XScuTimer_Stop(&TimerInstance);
	    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
	    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
	       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
	     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
	     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
	     	cleanup_platform();
			return;
		}
		Status = Xil_WaitForEventSet(1000000U, 1, &DmaError);
		if (Status == XST_SUCCESS) {
			if (!DmaError) {
				xil_printf("Ending program due to DMA error, Status: %d\r\n", Status);
				tcp_abort(pcb);
		    	XScuTimer_Stop(&TimerInstance);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	cleanup_platform();
				return;
			}
		}
        return;
    }

    xil_printf("Got to here 2\r\n");

    if ((IrqStatus & XAXIDMA_IRQ_IOC_MASK)) {
    	xil_printf("Got to here 3\r\n");
        if (pcb == NULL || pcb->state != ESTABLISHED) {
            xil_printf("PCB invalid or not connected, state: %d\r\n",
                      pcb ? pcb->state : -1);
			xil_printf("RX SimpleTransfer initiated\r\n");
			DmaError = 0;
			int Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaRxBufferPtr,
			4, XAXIDMA_DEVICE_TO_DMA);
			if (Status != XST_SUCCESS) {
				xil_printf("Failed to receive data from AXI DMA %d\r\n", Status);
				tcp_abort(pcb);
		    	XScuTimer_Stop(&TimerInstance);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	cleanup_platform();
				return;
			}
			Status = Xil_WaitForEventSet(1000000U, 1, &DmaError);
			if (Status == XST_SUCCESS) {
				if (!DmaError) {
					xil_printf("Ending program due to DMA error, Status: %d\r\n", Status);
					tcp_abort(pcb);
			    	XScuTimer_Stop(&TimerInstance);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
			       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
			     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	cleanup_platform();
					return;
				}
			}
            return;
        }

        if (DmaRepeat) {
        	DmaRepeat = 0;
        	xil_printf("RX SimpleTransfer initiated\r\n");
			Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaRxBufferPtr,
			4, XAXIDMA_DEVICE_TO_DMA);
			if (Status != XST_SUCCESS) {
				xil_printf("Failed to receive data from AXI DMA %d\r\n", Status);
				tcp_abort(pcb);
				XScuTimer_Stop(&TimerInstance);
				XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
				XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
				XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
				XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				cleanup_platform();
				return;
			}
        	return;
        }

        if (tcp_sndbuf(pcb) >= 4) {
			xil_printf("Got to here 4\r\n");
		    Xil_DCacheInvalidateRange((UINTPTR) DmaRxBufferPtr, 32);
		    u32_t result = ((u32)(DmaRxBufferPtr[0])) | ((u32)(DmaRxBufferPtr[1]) << 8) |
		    			((u32)(DmaRxBufferPtr[2]) << 16) | ((u32)(DmaRxBufferPtr[3]) << 24);
		    result = lwip_htonl(result);
		    rx_buffer[0] = (u8)(result);
		    rx_buffer[1] = (u8)(result >> 8);
		   	rx_buffer[2] = (u8)(result >> 16);
		    rx_buffer[3] = (u8)(result >> 24);
		    err = tcp_write(pcb, (void*) rx_buffer, 4, TCP_WRITE_FLAG_COPY);
		    if (err != ERR_OK) {
		    	xil_printf("TCP write error %d\r\n", err);
				tcp_abort(pcb);
		    	XScuTimer_Stop(&TimerInstance);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		      	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	cleanup_platform();
		    	return;
		    }
		    xil_printf("Got to here 5\r\n");
		    err = tcp_output(pcb);
		    if (err != ERR_OK) {
		    	xil_printf("TCP output error %d\r\n", err);
				tcp_abort(pcb);
		    	XScuTimer_Stop(&TimerInstance);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		      	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	cleanup_platform();
		    	return;
		    }
		} else {
			xil_printf("DMA RX waiting\r\n");
			xil_printf("RX SimpleTransfer initiated\r\n");
			DmaError = 0;
			int Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaRxBufferPtr,
			4, XAXIDMA_DEVICE_TO_DMA);
			if (Status != XST_SUCCESS) {
				xil_printf("Failed to receive data from AXI DMA %d\r\n", Status);
				tcp_abort(pcb);
		    	XScuTimer_Stop(&TimerInstance);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	cleanup_platform();
				return;
			}
			Status = Xil_WaitForEventSet(1000000U, 1, &DmaError);
			if (Status == XST_SUCCESS) {
				if (!DmaError) {
					xil_printf("Ending program due to DMA error, Status: %d\r\n", Status);
					tcp_abort(pcb);
			    	XScuTimer_Stop(&TimerInstance);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
			       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
			     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	cleanup_platform();
					return;
				}
			}
		}
        xil_printf("DMA RX completed\r\n");
        if (a_cols != 1) {
        	DmaRepeat = 1;
        } else {
        	if (!firstrxdone) {
        		DmaRepeat = 1;
        	}
        }
        firstrxdone = 1;

        rx_a_row++;
        if (rx_a_row == a_rows) {
        	rx_a_row = 0;
        	rx_b_col++;
        	if (rx_b_col == b_cols) {
        		DmaRxFinal = 1;
        	}
        }
        /* Start next S2MM DMA transfer */
        if (!DmaRxFinal) {
        	xil_printf("RX SimpleTransfer initiated\r\n");
			Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaRxBufferPtr,
			4, XAXIDMA_DEVICE_TO_DMA);
			if (Status != XST_SUCCESS) {
				xil_printf("Failed to receive data from AXI DMA %d\r\n", Status);
				tcp_abort(pcb);
				XScuTimer_Stop(&TimerInstance);
				XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
				XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
				XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
				XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				cleanup_platform();
				return;
			}
        }
		DmaError = 1;
    }
}

static void DmaTxIntrHandler(void *Callback)
{
    u32 IrqStatus;
    int TimeOut;
    XAxiDma *AxiDmaInst = (XAxiDma *)Callback;

    IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DMA_TO_DEVICE);
    XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DMA_TO_DEVICE);

    if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK)) {
        return;
    }

    if ((IrqStatus & XAXIDMA_IRQ_ERROR_MASK)) {
        xil_printf("DMA TX Error occurred\r\n");

        XAxiDma_Reset(AxiDmaInst);
        TimeOut = 10000;
        while (TimeOut) {
            if (XAxiDma_ResetIsDone(AxiDmaInst)) {
                break;
            }
            TimeOut -= 1;
        }
		Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaTxBufferPtr,
				8, XAXIDMA_DMA_TO_DEVICE);
		if (Status != XST_SUCCESS) {
			xil_printf("Failed to transfer data to AXI DMA %d\r\n", Status);
			tcp_abort(pcb);
	    	XScuTimer_Stop(&TimerInstance);
	    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
	    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
	       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
	     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
	     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
	     	cleanup_platform();
			return;
		}
        return;
    }

    if ((IrqStatus & XAXIDMA_IRQ_IOC_MASK)) {
        DmaTxDone = 1;
        xil_printf("DMA TX completed\r\n");
    }
}

void GpioHandler(void *CallbackRef)
{
    XGpio *GpioPtr = (XGpio *)CallbackRef;
    IntrFlag = 1;
    XGpio_InterruptClear(GpioPtr, GlobalIntrMask);
}

int main()
{
	 // Enable FCLK_RESET1_N
	    Xil_Out32(0xF8000008, 0x0000DF0D);
	    Xil_Out32(0xF8000240, 0x00000002);
#if LWIP_IPV6==0
	ip_addr_t ipaddr, netmask, gw;
	int Status;
#endif
	/* the mac address of the board. this should be unique per board */
	unsigned char mac_ethernet_address[] =
	{ 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };

	echo_netif = &server_netif;
#if defined (__arm__) && !defined (ARMR5)
#if XPAR_GIGE_PCS_PMA_SGMII_CORE_PRESENT == 1 || XPAR_GIGE_PCS_PMA_1000BASEX_CORE_PRESENT == 1
	ProgramSi5324();
	ProgramSfpPhy();
#endif
#endif

	/* Define this board specific macro in order perform PHY reset on ZCU102 */
#ifdef XPS_BOARD_ZCU102
	if (IicPhyReset()) {
		xil_printf("Error performing PHY reset \n\r");
		return -1;
	}
#endif

	DmaTxBufferPtr = (u8 *)TX_BUFFER_BASE;
	DmaRxBufferPtr = (u8 *)RX_BUFFER_BASE;

    /* Initialize DMA engine */
    XAxiDma_Config *Config=NULL;
    Config = XAxiDma_LookupConfig(XPAR_AXIDMA_0_DEVICE_ID);
    if (!Config) {
    	xil_printf("No DMA config found for %d\r\n",
    			XPAR_AXIDMA_0_DEVICE_ID);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    Status = XAxiDma_CfgInitialize(&AxiDma, Config);
    if (Status != XST_SUCCESS) {
    	xil_printf("DMA Initialization failed %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    if (XAxiDma_HasSg(&AxiDma)) {
    	xil_printf("Device configured as SG mode \r\n");
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    /* Initialize GPIO */
    Status = XGpio_Initialize(&Gpio, XPAR_GPIO_0_DEVICE_ID);
    if (Status != XST_SUCCESS) {
    	xil_printf("GPIO initialization failed %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    /* Initialize interrupt */

	init_platform();

    /* Setup Interrupt for DMA */
    XScuGic_SetPriorityTriggerType(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID,
    		0xA0, 0x3);
    XScuGic_SetPriorityTriggerType(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID,
    		0xA0, 0x3);

    Status = XScuGic_Connect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID,
    		(Xil_InterruptHandler) DmaTxIntrHandler, &AxiDma);
    if (Status != XST_SUCCESS) {
    	xil_printf("Failed to connect DMA TX interrupt %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    Status = XScuGic_Connect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID,
        		(Xil_InterruptHandler) DmaRxIntrHandler, &AxiDma);
    if (Status != XST_SUCCESS) {
        xil_printf("Failed to connect DMA RX interrupt %d\r\n", Status);
        XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
        Xil_DCacheDisable();
        return XST_FAILURE;
    }

    XScuGic_Enable(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    XScuGic_Enable(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);

    /* Setup Interrupt for GPIO */
    XScuGic_SetPriorityTriggerType(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID,
    		0xA0, 0x3);

    Status = XScuGic_Connect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID,
    		(Xil_ExceptionHandler) GpioHandler, &Gpio);
    if (Status != XST_SUCCESS) {
    	xil_printf("Failed to connect GPIO interrupt %d\r\n", Status);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    XGpio_InterruptEnable(&Gpio, XGPIO_IR_MASK);
    XGpio_InterruptGlobalEnable(&Gpio);

    /* Enable DMA interrupts */
    XAxiDma_IntrDisable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			    XAXIDMA_DMA_TO_DEVICE);

    XAxiDma_IntrDisable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			    XAXIDMA_DEVICE_TO_DMA);

    XAxiDma_IntrEnable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			   XAXIDMA_DMA_TO_DEVICE);

    XAxiDma_IntrEnable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			   XAXIDMA_DEVICE_TO_DMA);

    /* Flush buffers before DMA transfer */
    Xil_DCacheFlushRange((UINTPTR)DmaTxBufferPtr, 0x00000100);
    // Xil_DCacheFlushRange((UINTPTR)DmaRxBufferPtr, 0x00000100);


#if LWIP_IPV6==0
#if LWIP_DHCP==1
	ipaddr.addr = 0;
	gw.addr = 0;
	netmask.addr = 0;
#else
	/* initialize IP addresses to be used */
	IP4_ADDR(&ipaddr,  192, 168,   1, 10);
	IP4_ADDR(&netmask, 255, 255, 255,  0);
	IP4_ADDR(&gw,      192, 168,   1,  1);
#endif
#endif
	print_app_header();

	lwip_init();

#if (LWIP_IPV6 == 0)
	/* Add network interface to the netif_list, and set it as default */
	if (!xemac_add(echo_netif, &ipaddr, &netmask,
		       &gw, mac_ethernet_address,
		       PLATFORM_EMAC_BASEADDR)) {
		xil_printf("Error adding N/W interface\n\r");
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
    	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
    	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
    	cleanup_platform();
		return -1;
	}
#else
	/* Add network interface to the netif_list, and set it as default */
	if (!xemac_add(echo_netif, NULL, NULL, NULL, mac_ethernet_address,
		       PLATFORM_EMAC_BASEADDR)) {
		xil_printf("Error adding N/W interface\n\r");
		return -1;
	}
	echo_netif->ip6_autoconfig_enabled = 1;

	netif_create_ip6_linklocal_address(echo_netif, 1);
	netif_ip6_addr_set_state(echo_netif, 0, IP6_ADDR_VALID);

	print_ip6("\n\rBoard IPv6 address ", &echo_netif->ip6_addr[0].u_addr.ip6);

#endif
	netif_set_default(echo_netif);

#ifndef SDT
	/* now enable interrupts */
	platform_enable_interrupts();
#endif

	/* specify that the network if is up */
	netif_set_up(echo_netif);

#if (LWIP_IPV6 == 0)
#if (LWIP_DHCP==1)
	/* Create a new DHCP client for this interface.
	 * Note: you must call dhcp_fine_tmr() and dhcp_coarse_tmr() at
	 * the predefined regular intervals after starting the client.
	 */
	dhcp_start(echo_netif);
	dhcp_timoutcntr = 240;

	while (((echo_netif->ip_addr.addr) == 0) && (dhcp_timoutcntr > 0)) {
		xemacif_input(echo_netif);
	}

	if (dhcp_timoutcntr <= 0) {
		if ((echo_netif->ip_addr.addr) == 0) {
			xil_printf("DHCP Timeout\r\n");
			xil_printf("Configuring default IP of 192.168.1.10\r\n");
			IP4_ADDR(&(echo_netif->ip_addr),  192, 168,   1, 10);
			IP4_ADDR(&(echo_netif->netmask), 255, 255, 255,  0);
			IP4_ADDR(&(echo_netif->gw),      192, 168,   1,  1);
		}
	}

	ipaddr.addr = echo_netif->ip_addr.addr;
	gw.addr = echo_netif->gw.addr;
	netmask.addr = echo_netif->netmask.addr;
#endif

	print_ip_settings(&ipaddr, &netmask, &gw);

#endif
	/* start the application (web server, rxtest, txtest, etc..) */
	start_application();

	/* receive and process packets */
	while (1) {
		if (TcpFastTmrFlag) {
			xil_printf("Fast!!!!\r\n");
			tcp_fasttmr();
			xil_printf("Fast done\r\n");
			TcpFastTmrFlag = 0;
		}
		if (TcpSlowTmrFlag) {
			xil_printf("Slow!!!!\r\n");
			tcp_slowtmr();
			xil_printf("Slow done\r\n");
			TcpSlowTmrFlag = 0;
		}
		xemacif_input(echo_netif);
	}

	/* never reached */
	cleanup_platform();

	return 0;
}
