/******************************************************************************
* Copyright (C) 2023 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/
/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "xil_printf.h"
#include "netif/xadapter.h"
#include "xtmrctr.h"
#include "xil_exception.h"
#include "xparameters.h"
#include "xdebug.h"
#include "xil_util.h"
#include "xil_cache.h"
#ifdef SDT
#include "xinterrupt_wrap.h"
#else
#ifdef XPAR_INTC_0_DEVICE_ID
#include "xintc.h"
#else
#include "xscugic.h"
#endif
#endif
#include "lwip/err.h"
#include "lwip/tcp.h"
#include "lwip/init.h"
#include "lwipopts.h"
#include "lwip/timeouts.h"


#include "xgpio.h"
#include "xaxidma.h"
#define MEM_BASE_ADDR (XPAR_PS7_DDR_0_S_AXI_BASEADDR + 0x01000000)
#define TX_BUFFER_BASE (MEM_BASE_ADDR + 0x00100000)
#define RX_BUFFER_BASE (MEM_BASE_ADDR + 0x00300000)
u8 *DmaTxBufferPtr;
u8 *DmaRxBufferPtr;
static XScuGic Interrupt;
static XTmrCtr Timer;
XAxiDma AxiDma;
XGpio Gpio;
volatile u32 DmaTxDone = 0;
volatile u32 DmaRxDone = 0;
volatile u32 DmaError = 0;
static u16 GlobalIntrMask = 1;
static volatile u32 IntrFlag = 0;
u32_t tx_buf_i = 0;
u32_t tx_buffer[8];
u32_t init_buffer[8];
u32_t init_buf_i = 0;
u8_t rx_buffer[4];
u32_t a_cols;
u32_t fraction_bits;
u32_t tcperror = 0;
u32_t accepted = 0;
u32_t curr_a_col = 0;
u32_t firstrxdone = 0;
struct netif *netif, server_netif;
struct tcp_pcb* pcb;
err_t err;
volatile int tcptmrflag = 0;

static void DmaRxIntrHandler(void *Callback)
{
	u32 IrqStatus;
	int TimeOut;
	XAxiDma *AxiDmaInst = (XAxiDma *)Callback;

	/* Read pending interrupts */
	IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DEVICE_TO_DMA);

	/* Acknowledge pending interrupts */
	XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DEVICE_TO_DMA);

	/*
	 * If no interrupt is asserted, we do not do anything
	 */
	if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK)) {
		return;
	}

	/*
	 * If error interrupt is asserted, raise error flag, reset the
	 * hardware to recover from the error, and return with no further
	 * processing.
	 */
	if ((IrqStatus & XAXIDMA_IRQ_ERROR_MASK)) {

		DmaError = 1;

		/* Reset could fail and hang
		 * NEED a way to handle this or do not call it??
		 */
		XAxiDma_Reset(AxiDmaInst);

		TimeOut = 10000;

		while (TimeOut) {
			if (XAxiDma_ResetIsDone(AxiDmaInst)) {
				break;
			}

			TimeOut -= 1;
		}

		return;
	}

	/*
	 * If completion interrupt is asserted, then set RxDone flag
	 */
	if ((IrqStatus & XAXIDMA_IRQ_IOC_MASK)) {
		if (tcp_sndbuf(pcb) > 4) {
		    Xil_DCacheInvalidateRange((UINTPTR) DmaRxBufferPtr, 4);
		    u32_t result = ((u32)(DmaRxBufferPtr[0])) | ((u32)(DmaRxBufferPtr[1]) << 8) |
		    			((u32)(DmaRxBufferPtr[2]) << 16) | ((u32)(DmaRxBufferPtr[3]) << 24);
		    result = lwip_htonl(result);
		    rx_buffer[0] = (u8)(result);
		    rx_buffer[1] = (u8)(result >> 8);
		   	rx_buffer[2] = (u8)(result >> 16);
		    rx_buffer[3] = (u8)(result >> 24);
		    err = tcp_write(pcb, (void*) rx_buffer, 4, TCP_WRITE_FLAG_COPY);
		    if (err != ERR_OK) {
		    	xil_printf("TCP write error %d\r\n", err);
				tcp_abort(pcb);
		    	XTmrCtr_Stop(&Timer, 0);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	Xil_DCacheDisable();
		    	return;
		    }
		    err = tcp_output(pcb);
		    if (err != ERR_OK) {
		    	xil_printf("TCP output error %d\r\n", err);
				tcp_abort(pcb);
		    	XTmrCtr_Stop(&Timer, 0);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	Xil_DCacheDisable();
		    	return;
		    }
		}
		DmaRxDone = 1;
	}
}

static void DmaTxIntrHandler(void *Callback)
{

	u32 IrqStatus;
	int TimeOut;
	XAxiDma *AxiDmaInst = (XAxiDma *)Callback;

	/* Read pending interrupts */
	IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DMA_TO_DEVICE);

	/* Acknowledge pending interrupts */


	XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DMA_TO_DEVICE);

	/*
	 * If no interrupt is asserted, we do not do anything
	 */
	if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK)) {

		return;
	}

	/*
	 * If error interrupt is asserted, raise error flag, reset the
	 * hardware to recover from the error, and return with no further
	 * processing.
	 */
	if ((IrqStatus & XAXIDMA_IRQ_ERROR_MASK)) {

		DmaError = 1;

		/*
		 * Reset should never fail for transmit channel
		 */
		XAxiDma_Reset(AxiDmaInst);

		TimeOut = 10000;

		while (TimeOut) {
			if (XAxiDma_ResetIsDone(AxiDmaInst)) {
				break;
			}

			TimeOut -= 1;
		}

		return;
	}

	/*
	 * If Completion interrupt is asserted, then set the TxDone flag
	 */
	if ((IrqStatus & XAXIDMA_IRQ_IOC_MASK)) {

		DmaTxDone = 1;
	}
}

void GpioHandler(void *CallbackRef)
{
	XGpio *GpioPtr = (XGpio *)CallbackRef;

	IntrFlag = 1;

	/* Clear the Interrupt */
	XGpio_InterruptClear(GpioPtr, GlobalIntrMask);

}

err_t recv_callback(void *arg, struct tcp_pcb *tpcb,
                               struct pbuf *p, err_t err)
{
	/* do not read the packet if we are not in ESTABLISHED state */
	if (!p) {
		tcp_close(tpcb);
		tcp_recv(tpcb, NULL);
		xil_printf("TCP connection is not established\r\n");
		return ERR_OK;
	}

	/* indicate that the packet has been received */
	tcp_recved(tpcb, p->len);

	for (u16_t i = 0; i < p->len; ++i) {
		if (tx_buf_i > 7) {
			tx_buf_i = 0;
			u32_t tdata_a = (tx_buffer[0]) | (tx_buffer[1] << 8) |
							(tx_buffer[2] << 16) | (tx_buffer[3] << 24);
			u32_t tdata_b = (tx_buffer[4]) | (tx_buffer[5] << 8) |
							(tx_buffer[6] << 16) | (tx_buffer[7] << 24);
			tdata_a = lwip_ntohl(tdata_a);
			tdata_b = lwip_ntohl(tdata_b);
			DmaTxBufferPtr[7] = (u8)(tdata_a >> 24);
			DmaTxBufferPtr[6] = (u8)(tdata_a >> 16);
			DmaTxBufferPtr[5] = (u8)(tdata_a >> 8);
			DmaTxBufferPtr[4] = (u8)(tdata_a);
			DmaTxBufferPtr[3] = (u8)(tdata_b >> 24);
			DmaTxBufferPtr[2] = (u8)(tdata_b >> 16);
			DmaTxBufferPtr[1] = (u8)(tdata_b >> 8);
			DmaTxBufferPtr[0] = (u8)(tdata_b);
			Xil_DCacheFlushRange((UINTPTR) DmaTxBufferPtr, 8);
			int Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaTxBufferPtr,
					8, XAXIDMA_DMA_TO_DEVICE);
			if (Status != XST_SUCCESS) {
				xil_printf("Failed to transfer data to AXI DMA %d\r\n", Status);
				tcp_abort(tpcb);
				XScuTimer_Stop(&Timer);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
		    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
		       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
		     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
		     	cleanup_platform();
				return ERR_ABRT;
			}
			Status = Xil_WaitForEventSet(1000000U, 1, &DmaTxDone);
			if (Status != XST_SUCCESS) {
				if (!DmaTxDone) {
					xil_printf("DMA TxDone is not 1 %d, Error value: %d\r\n", Status, DmaError);
					tcp_abort(tpcb);
			    	XScuTimer_Stop(&Timer);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
			       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
			     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	cleanup_platform();
					return ERR_ABRT;
				}
			}
			DmaTxDone = 0;
			curr_a_col++;
			if (curr_a_col == a_cols) {
				if (firstrxdone) {
					if (!DmaRxDone) {
						Status = Xil_WaitForEventSet(1000000U, 1, &DmaRxDone);
						if (Status == XST_SUCCESS) {
							if (!DmaRxDone) {
								xil_printf("DMA RxDone is not 1 %d, Error %d\r\n", Status, DmaError);
								tcp_abort(tpcb);
						    	XScuTimer_Stop(&Timer);
						    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
						    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
						       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
						     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
						     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
						     	cleanup_platform();
								return ERR_ABRT;
							}
						}
					}
					DmaRxDone = 0;
				}
				Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaRxBufferPtr,
    			4, XAXIDMA_DEVICE_TO_DMA);
				if (Status != XST_SUCCESS) {
					xil_printf("Failed to receive data from AXI DMA %d\r\n", Status);
					tcp_abort(tpcb);
			    	XScuTimer_Stop(&Timer);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
			       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
			     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	cleanup_platform();
					return ERR_ABRT;
				}
				curr_a_col = 0;
				firstrxdone = 1;
			}
		}
		tx_buffer[tx_buf_i] = (u32_t)(pbuf_get_at(p, i));
		tx_buf_i++;
		if (firstrxdone) {

		}
	}

	/* free the received pbuf */
	pbuf_free(p);
	return ERR_OK;
}

err_t recv_callback_init(void *arg, struct tcp_pcb *tpcb,
								 struct pbuf *p, err_t err)
{
	/* do not read the packet if we are not in ESTABLISHED state */
	if (!p) {
		tcp_close(tpcb);
		tcp_recv(tpcb, NULL);
		xil_printf("TCP connection is not established\r\n");
		return ERR_OK;
	}

	/* indicate that the packet has been received */
	tcp_recved(tpcb, p->len);

	for (u16_t i = 0; i < p->len; ++i) {
		if (init_buf_i > 7) {
			if (tx_buf_i > 7) {
				tx_buf_i = 0;
				u32_t tdata_a = (tx_buffer[0]) | (tx_buffer[1] << 8) |
								(tx_buffer[2] << 16) | (tx_buffer[3] << 24);
				u32_t tdata_b = (tx_buffer[4]) | (tx_buffer[5] << 8) |
								(tx_buffer[6] << 16) | (tx_buffer[7] << 24);
				tdata_a = lwip_ntohl(tdata_a);
				tdata_b = lwip_ntohl(tdata_b);
				DmaTxBufferPtr[7] = (u8)(tdata_a >> 24);
				DmaTxBufferPtr[6] = (u8)(tdata_a >> 16);
				DmaTxBufferPtr[5] = (u8)(tdata_a >> 8);
				DmaTxBufferPtr[4] = (u8)(tdata_a);
				DmaTxBufferPtr[3] = (u8)(tdata_b >> 24);
				DmaTxBufferPtr[2] = (u8)(tdata_b >> 16);
				DmaTxBufferPtr[1] = (u8)(tdata_b >> 8);
				DmaTxBufferPtr[0] = (u8)(tdata_b);
				int Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaTxBufferPtr,
						8, XAXIDMA_DMA_TO_DEVICE);
				if (Status != XST_SUCCESS) {
					xil_printf("Failed to transfer data to AXI DMA %d\r\n", Status);
					tcp_abort(tpcb);
			    	XScuTimer_Stop(&Timer);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
			    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
			       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
			     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
			     	cleanup_platform();
					return ERR_ABRT;
				}
				Status = Xil_WaitForEventSet(1000000U, 1, &DmaTxDone);
				if (Status == XST_SUCCESS) {
					if (!DmaTxDone) {
						xil_printf("DMA TxDone is not 1 %d, Error value: %d\r\n", Status, DmaError);
						tcp_abort(tpcb);
				    	XScuTimer_Stop(&Timer);
				    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
				    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
				       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
				     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				     	cleanup_platform();
						return ERR_ABRT;
					}
				}
				DmaTxDone = 0;
				curr_a_col++;
				if (curr_a_col == a_cols) {
					if (firstrxdone) {
						if (!DmaRxDone) {
							Status = Xil_WaitForEventSet(1000000U, 1, &DmaRxDone);
							if (Status == XST_SUCCESS) {
								if (!DmaRxDone) {
									xil_printf("DMA RxDone is not 1 %d, Error %d\r\n", Status, DmaError);
									tcp_abort(tpcb);
							    	XScuTimer_Stop(&Timer);
							    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
							    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
							       	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
							     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
							     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
							     	cleanup_platform();
									return ERR_ABRT;
								}
							}
						}
						DmaRxDone = 0;
					}
					Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR) DmaRxBufferPtr,
	    			4, XAXIDMA_DEVICE_TO_DMA);
					if (Status != XST_SUCCESS) {
						xil_printf("Failed to receive data from AXI DMA %d\r\n", Status);
						tcp_abort(tpcb);
				    	XScuTimer_Stop(&Timer);
				    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
				    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
				      	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
				     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
				     	cleanup_platform();
						return ERR_ABRT;
					}
					curr_a_col = 0;
					firstrxdone = 1;
				}
			}
			tx_buffer[tx_buf_i] = (u32_t)(pbuf_get_at(p, i));
			tx_buf_i++;
		} else {
			init_buffer[init_buf_i] = (u32_t)(pbuf_get_at(p, i));
			init_buf_i++;
			if (init_buf_i == 8) {
				a_cols = (init_buffer[0]) | (init_buffer[1] << 8) |
						(init_buffer[2] << 16) | (init_buffer[3] << 24);
				a_cols = lwip_ntohl(a_cols);
				fraction_bits = (init_buffer[4]) | (init_buffer[5] << 8) |
						(init_buffer[6] << 16) | (init_buffer[7] << 24);
				fraction_bits = lwip_ntohl(fraction_bits);
				XGpio_DiscreteWrite(&Gpio, 1, fraction_bits);
				XGpio_DiscreteWrite(&Gpio, 2, a_cols);
				// disable FCLK_RESET1_N
				Xil_Out32(0xF8000240, 0x00000000);
				tcp_recv(tpcb, recv_callback);
			}
		}
	}

	/* free the received pbuf */
	pbuf_free(p);
	return ERR_OK;
}

err_t accept_callback(void *arg, struct tcp_pcb *newpcb, err_t err)
{
	accepted = 1;
	xil_printf("Connection accepted\r\n");
	return ERR_OK;
}

void TimerCounterHandler(void *CallBackRef, u8 TmrCtrNumber) {
	XTmrCtr *TimerInstance = (XTmrCtr*) CallBackRef;
	static int DetectEthLinkStatus = 0;
	static int tcp_timer = 0;
	static int ResetRxCntr = 0;
	ResetRxCntr++;
	DetectEthLinkStatus++;
	tcp_timer++;
	if(tcp_timer % 5 == 0) {
		tcptmrflag = 1;
	}
	if (ResetRxCntr >= 2000) {
		xemacpsif_resetrx_on_no_rxdata(netif);
		ResetRxCntr = 0;
	}
	if (DetectEthLinkStatus == 20) {
		eth_link_detect(netif);
		DetectEthLinkStatus = 0;
	}
	XTmrCtr_Reset(TimerInstance, 0);
}

int main()
{

    // enable FCLK_RESET1_N
    Xil_Out32(0xF8000008, 0x0000DF0D);
    Xil_Out32(0xF8000240, 0x00000002);

    int Status;
    ip_addr_t ipaddr, netmask, gw;

    DmaTxBufferPtr = (u8 *)TX_BUFFER_BASE;
    DmaRxBufferPtr = (u8 *)RX_BUFFER_BASE;

    /* The MAC address of the board.
     * This should be unique per board" */
    unsigned char mac_ethernet_address[] =
    {0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };

    /* Initialize DMA engine */
    XAxiDma_Config *Config=NULL;
    Config = XAxiDma_LookupConfig(XPAR_AXIDMA_0_DEVICE_ID);
    if (!Config) {
    	xil_printf("No DMA config found for %d\r\n",
    			XPAR_AXIDMA_0_DEVICE_ID);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    Status = XAxiDma_CfgInitialize(&AxiDma, Config);
    if (Status != XST_SUCCESS) {
    	xil_printf("DMA Initialization failed %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    if (XAxiDma_HasSg(&AxiDma)) {
    	xil_printf("Device configured as SG mode \r\n");
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    /* Initialize Timer engine */
    Status = XTmrCtr_Initialize(&Timer, XPAR_TMRCTR_0_DEVICE_ID);
    if (Status != XST_SUCCESS) {
    	xil_printf("Timer initialization failed %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    Status = XTmrCtr_SelfTest(&Timer, 0);
    if (Status != XST_SUCCESS) {
    	xil_printf("Timer failed self-test %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    /* Initialize GPIO */
    Status = XGpio_Initialize(&Gpio, XPAR_GPIO_0_DEVICE_ID);
    if (Status != XST_SUCCESS) {
    	xil_printf("GPIO initialization failed %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    /* Initialize Interrupt */
    XScuGic_Config *IntcConfig;
    IntcConfig = XScuGic_LookupConfig(XPAR_SCUGIC_0_DEVICE_ID);
    if (NULL == IntcConfig) {
    	xil_printf("No interrupt config found for %d\r\n",
    			XPAR_SCUGIC_0_DEVICE_ID);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    Status = XScuGic_CfgInitialize(&Interrupt, IntcConfig,
    					IntcConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) {
    	xil_printf("Interrupt initialization failed %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    Status = XScuGic_SelfTest(&Interrupt);
    if (Status != XST_SUCCESS) {
    	xil_printf("Interrupt failed self-test %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    /* Setup Interrupt Exception */
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
    		(Xil_ExceptionHandler) XScuGic_InterruptHandler,
			(void *) &Interrupt);
    Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);

    /* Setup Interrupt for DMA */
    XScuGic_SetPriorityTriggerType(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID,
    		0xA0, 0x3);
    XScuGic_SetPriorityTriggerType(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID,
    		0xA0, 0x3);

    Status = XScuGic_Connect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID,
    		(Xil_InterruptHandler) DmaTxIntrHandler, &AxiDma);
    if (Status != XST_SUCCESS) {
    	xil_printf("Failed to connect DMA TX interrupt %d\r\n", Status);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    Status = XScuGic_Connect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID,
        		(Xil_InterruptHandler) DmaRxIntrHandler, &AxiDma);
    if (Status != XST_SUCCESS) {
        xil_printf("Failed to connect DMA RX interrupt %d\r\n", Status);
        XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
        Xil_DCacheDisable();
        return XST_FAILURE;
    }

    XScuGic_Enable(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    XScuGic_Enable(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);

    /* Setup Interrupt for Timer */
    XScuGic_SetPriorityTriggerType(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID,
    		0xA0, 0x3);

    Status = XScuGic_Connect(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID,
    		(Xil_ExceptionHandler) XTmrCtr_InterruptHandler, &Timer);
    if (Status != XST_SUCCESS) {
    	xil_printf("Failed to connect Timer interrupt %d\r\n", Status);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    XScuGic_Enable(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
    XTmrCtr_SetHandler(&Timer, TimerCounterHandler, &Timer);
    XTmrCtr_SetOptions(&Timer, 0, XTC_INT_MODE_OPTION | XTC_DOWN_COUNT_OPTION);
    XTmrCtr_SetResetValue(&Timer, 0, 5000);

    /* Setup Interrupt for GPIO */
    XScuGic_SetPriorityTriggerType(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID,
    		0xA0, 0x3);

    Status = XScuGic_Connect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID,
    		(Xil_ExceptionHandler) GpioHandler, &Gpio);
    if (Status != XST_SUCCESS) {
    	xil_printf("Failed to connect GPIO interrupt %d\r\n", Status);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
    	XScuGic_Disable(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
    	Xil_DCacheDisable();
    	return XST_FAILURE;
    }

    XGpio_InterruptEnable(&Gpio, XGPIO_IR_MASK);
    XGpio_InterruptGlobalEnable(&Gpio);

    /* Enable DMA interrupts */
    XAxiDma_IntrDisable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			    XAXIDMA_DMA_TO_DEVICE);

    XAxiDma_IntrDisable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			    XAXIDMA_DEVICE_TO_DMA);

    XAxiDma_IntrEnable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			   XAXIDMA_DMA_TO_DEVICE);

    XAxiDma_IntrEnable(&AxiDma, XAXIDMA_IRQ_ALL_MASK,
    			   XAXIDMA_DEVICE_TO_DMA);

    /* Flush buffers before DMA transfer */
    Xil_DCacheFlushRange((UINTPTR)DmaTxBufferPtr, 0x00000100);
    Xil_DCacheFlushRange((UINTPTR)DmaRxBufferPtr, 0x00000100);

    // TcpTmrFlag = 0;

    netif = &server_netif;

    /* initialize IP addresses to be used */
    IP4_ADDR(&ipaddr,  192, 168,   1, 10);
    IP4_ADDR(&netmask, 255, 255, 255,  0);
    IP4_ADDR(&gw,      0, 0,   0,  0);

    lwip_init();

    if (!xemac_add(netif, &ipaddr, &netmask,
    		       &gw, mac_ethernet_address,
				   XPAR_XEMACPS_0_BASEADDR)) {
    	xil_printf("Error adding N/W interface\n\r");
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
       	XScuGic_Disable(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
       	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
    	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
    	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
    	Xil_DCacheDisable();
       	return -1;
    }

    netif_set_default(netif);
    netif_set_up(netif);

    /* start timer */
    XTmrCtr_Start(&Timer, 0);

    /* start the application */
    u16_t port = 7;

    pcb = tcp_new_ip_type(IPADDR_TYPE_V4);
    if (!pcb) {
    	xil_printf("Error creating PCB. Out of memory\n\r");
    	XTmrCtr_Stop(&Timer, 0);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
       	XScuGic_Disable(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
       	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
      	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
     	Xil_DCacheDisable();
    	return -1;
    }

    err = tcp_bind(pcb, IP_ADDR_ANY, port);
    if (err != ERR_OK) {
    	xil_printf("Unable to bind to port %d: err = %d\n\r", port, err);
    	XTmrCtr_Stop(&Timer, 0);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
       	XScuGic_Disable(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
       	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
      	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
     	Xil_DCacheDisable();
    	return -1;
    }

    tcp_arg(pcb, NULL);
    tcp_recv(pcb, recv_callback_init);
    tcp_accept(pcb, accept_callback);

    pcb = tcp_listen(pcb);
    if (!pcb) {
    	xil_printf("Out of memory while tcp_listen\n\r");
    	XTmrCtr_Stop(&Timer, 0);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID);
    	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID);
       	XScuGic_Disable(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
       	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_TMRCTR_0_VEC_ID);
      	XGpio_InterruptDisable(&Gpio, XGPIO_IR_MASK);
     	XScuGic_Disable(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
     	XScuGic_Disconnect(&Interrupt, XPAR_FABRIC_GPIO_0_VEC_ID);
     	Xil_DCacheDisable();
    	return -1;
    }

    xil_printf("Got past this point");

    while(1) {
    	if (tcptmrflag) {
    		xil_printf("Checking timeouts\r\n");
    		sys_check_timeouts();
    		xil_printf("Successfully checked timeouts\r\n");
    		tcptmrflag = 0;
    	}
    	xemacif_input(netif);
    }
    return XST_SUCCESS;
}
